# 19. 프로토타입

> 자바스크립트를 이루는 거의 모든 것은 **객체**다!
> 

### 0. 클래스

ES6에서 도입된 클래스.

클래스는 함수 기반으로 작성되었으며 프로토타입 기반 패턴인데 표현법이 바뀐 것이라 보면 된다.

완전히 동일하지는 않지만, 클래스와 생성자 함수 모두 프로토타입 기반의 인스턴스를 생성합니다.

### 1. 객체지향 프로그래밍

- **객체**
    - 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
    - 상태 데이터와 동작을 하나의 논리적인 다누이로 묶은 복합적인 자료구조

객체지향 프로그래밍은 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임입니다.

객체지향 프로그래밍은 객체의 상태를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어 생각하는 것이라 볼 수 있습니다.

### 2. 상속과 프로토타입

- **상속**
    - 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
    - 코드 재사용에 유리하다.
    - 단점
        - 그냥 생성자 함수로 생성 시, 동일한 메서드를 중복 소유 하여 메모리를 낭비할 수 있다.
        - 해결책: 프로토타입 기반으로 상속을 구현하면 중복 제거가 가능하다.
        
        ```jsx
        function Circle(radius) {
        	this.radius = radius;
        
        	// 여기 안에 아래와 같이 쓰면 중복 생성된다.
        	this.getArea = function () {
        		return Math.PI * this.radius ** 2;
        	}
        }
        
        // 개선된 방향: 프로토타입을 사용해 상속한다.
        Circle.prototype.getArea = function () {
        	return Math.PI * this.radius ** 2;
        }
        ```
        

### 3. 프로토타입 객체

위와 같이 프로토타입 객체는 객체 간 상속을 구현하기 위해 사용된다.

모든 객체는 `[[Prototype]]` 이라는 내부 슬롯을 가지고, 이 내부 슬롯의 값은 프로토타입의 참조이다. (null일 때도 있다.)

즉, 모든 객체는 하나의 프로토타입을 가지며, 모든 프로토타입은 생성자 함수와 연결되어 있다.

객체와 프로토타입과 생성자 함수는 연결되어 있다고 보면 된다.

1. **__proto__ 접근자 프로퍼티**
    
    모든 객체는 __proto__ 를 통해 자신의 프로토타입에 간접적 접근이 가능하다.
    
    모든 객체가  __proto__ 를 사용하는 것은 아니기 때문에 코드 내에서 직접 사용하는 것은 권장되지 않는다. (Object.prototype을 상속받지 않는 경우 사용할 수 없기 때문이다.)
    
    따라서 아래와 같은 메서드가 추천된다.
    
    - Object.getPrototypeOf: 프로토타입의 참조를 취득하고 싶은 경우
    - Object.setPrototypeOf: 프로토타입을 교체하고 싶을 경우

1. **함수 객체의 prototype 프로퍼티**
    
    함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 따라서 생성자 함수로 호출할 수 없는 화살표 함수나 축약형으로 표현되는 함수들은 prototype을 소유하지 않고, 프로토타입도 생성하지 않는다.
    
    ```jsx
    const testFunc = (name) => {
    	this.name = name;
    }
    
    console.log(testFunc.hasOwnProperty('prototype')); // false
    console.log(testFunc.prototype); // undefined;
    ```
    
    모든 객체가 가지고 있는 (Object.prototype으로 부터 상속받은) __proto__ 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.
    
2. **프로토타입의 constructor 프포퍼티와 생성자 함수**
    
    constructor 프로퍼티는 prototype 프로퍼티를 자신을 참조하고 있는 생성자 함수를 가리킨다.
    

### 4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

리터럴 표기법에 의해 명시적으로 new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않는 객체 생성 방식도 있다.

객체 리터럴이 평가될때 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하고 프로퍼티를 추가하도록 정의 되어 있다.

리터럴 표기법에 의해 생성된 객체더라도 상속을 위해 프로토타입이 필요하며, 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 가진다. 항상 쌍으로 존재하기 때문이다.

### 5. 프로토타입의 생성 시점

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

### 6. 객체 생성 방식과 프로토타입의 결정

모든 객체는 추상 연산 OrdinaryObjectCreate에 의해 생성된다.

프로토타입은 추상 연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정되고, 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.

### 7. 프로토타입 체인

자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.

아래에서 부터 타고 올라기에 결국 프로토타입 체인의 종점은 Object.prototype이 된다.

### 8. 오버라이딩과 프로퍼티 섀도잉

- 오버라이딩
    - 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식
- 오버로딩
    - 함수의 이름은 동일하지만 매개변수에 의해 메서드를 구분하여 호출하는 방식

하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제 하는 것은 불가능하다. 하위객체에서는 오직 접근(get)만 가능하다.

### 9. 프로토타입의 교체

프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다.

- prototype 프로퍼티에 직접 접근하여 프로토타입을 교체
- 이미 생성된 객체의 인스턴스로 프로토타입 교체

### 10. instanceof 연산자

instanceof 연산자는 프로토타입의 constructor  프로퍼티가 가리키는 생성자 함수를 찾지 않는다.

생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.

```jsx
객체 instanceof 생성자 함수 // boolean

// 아래는 Person의 prototype이 있을 때만 true가 반영된다.
console.log(me instanceOf Person);

// Person의 prototype을 바인딩 하는 법
const parent = {};
Person.prototype === parent; 
```

### 14. 프로퍼티 열거

객체의 모든 프로퍼티를 순회하며 열거 하려면 for … in을 사용한다.

for .. in은 Object.prototype의 프로퍼티는 열거되지 않고 상속받은 모든 프로토타입 프로퍼티를 열거한다.

상속 받은 객체 고유의 프로퍼티만 열거하기 위해서는 Object.keys, values, entries를 사용한다.
